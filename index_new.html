<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <!-- 外部资源 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- 主容器 -->
    <div id="container" class="w-screen h-screen">
        <canvas id="mainCanvas"></canvas>
    </div>

    <!-- 顶部导航栏 -->
    <nav id="top-nav">
        <div class="left-group">
            <button class="nav-btn" id="import-btn" data-tooltip="导入">
                <img src="icon\上传.png" alt="导入" width="38" height="38">
            </button>
            <div class="divider"></div>
            <button class="nav-btn" id="nav-export-json" disabled data-tooltip="导出" >
                <img src="icon\保存.png" alt="导出" width="38" height="38">
            </button>
            <div class="divider"></div>
            <button class="nav-btn" id="help-btn" data-tooltip="帮助"> <!-- 修正id拼写错误 -->
                <img src="icon\帮助.png" alt="帮助" width="38" height="38">
            </button>
        </div>
        <div class="right-group">
            <button class="nav-btn" id="undo-action" disabled data-tooltip="返回 Ctrl+Z">
                <img src="icon\返回.png" alt="返回" width="38" height="38">
            </button>
            <div class="divider"></div>
            <button class="nav-btn" id="redo-btn" disabled data-tooltip="重做 Ctrl+Y">
                <img src="icon\重做.png" alt="重做" width="38" height="38">
            </button>
            <div class="divider"></div>
            <div class="dropdown">
                <button class="nav-btn" data-tooltip="清除选项">
                    <img src="icon\清除.png" alt="清除" width="38" height="38">
                </button>
                <div class="dropdown-content">
                    <button id="clear-drawing">清除当前设计</button>
                    <button id="reset-all" style="color: #ff6b6b;">重置所有（包括参考平面且不可撤回）</button>
                </div>
            </div>
        </div>
    </nav>

    <!-- 初始导入弹窗 -->
    <div id="initial-modal">
        <div class="modal-content">
            <button id="close-modal" class="modal-close">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                </svg>
            </button>
            <div class="modal-title">导入模型</div>
            <input type="file" id="stl-loader" class="hidden" accept=".stl">
            <label for="stl-loader" class="modal-btn">导入STL模型</label>
            <input type="file" id="json-importer" class="hidden" accept=".json">
            <label for="json-importer" class="modal-btn">导入JSON设计</label>
            <div id="loader" class="loader mt-4 hidden mx-auto"></div>
        </div>
    </div>

    <!-- 底部操作栏 -->
    <div id="control-bar">
        <button class="control-btn" id="style-adjust">样式调整</button>
        <button class="control-btn" id="param-adjust">参数调整</button>
        <div class="divider"></div>
        <button class="control-btn" id="toggle-draw-mode">添加节点</button>
        <button class="control-btn" id="toggle-edit-mode">调整节点</button>
        <button class="control-btn" id="generate-uloop">生成U曲</button>
        <button class="control-btn" id="delete-mode">删除节点</button>

        <div class="divider"></div>
        <button class="control-btn" id="view-switch">视角切换</button>
    </div>

    <!-- 样式调整弹窗 -->
    <div id="style-modal">
        <div>
            <h3>样式调整</h3>
            <div class="space-y-6">
                <!-- 模型透明度控制 -->
                <div class="slider-control">
                    <label>模型透明度</label>
                    <input type="range" id="model-opacity" min="0" max="100" value="100">
                    <span class="slider-value" id="model-opacity-value">1.0</span>
                </div>
                <!-- 平面透明度控制 -->
                <div class="slider-control">
                    <label>平面透明度</label>
                    <input type="range" id="plane-opacity-adjust" min="0" max="100" value="50">
                    <span class="slider-value" id="plane-opacity-value">0.5</span>
                </div>
                <!-- 新增：场景亮度控制 -->
                <div class="slider-control">
                    <label>场景亮度</label>
                    <input type="range" id="scene-brightness" min="1" max="30" value="15"> <!-- 用1-30对应0.1-3.0 -->
                    <span class="slider-value" id="scene-brightness-value">1.5</span>
                </div>
            </div>
            <div class="mt-6 flex justify-end">
                <button id="close-style">关闭</button>
            </div>
        </div>
    </div>

    <!-- 右侧控制面板 -->
    <div id="control-panel">
        <div class="panel-header" id="panel-toggle">
            <div class="panel-title">控制面板</div>
            <div class="panel-toggle">▼</div>
        </div>
        <div class="panel-content" id="panel-content">
            <!-- 步骤1：建立参考平面 -->
            <div class="step-section" id="step-1">
    <div class="step-title cursor-pointer" onclick="toggleStep('step-1-content')">Step 1: 建立参考平面 ▼</div>
    <div id="step-1-content" class="step-content">
        <div id="plane-setup-section" class="step-actions">
            <div>
                <button class="step-btn btn-primary" id="plane-adjust">调整</button>
                <button class="step-btn btn-secondary" id="plane-confirm" disabled>确认</button>
            </div>
            <div>
                <button class="step-btn btn-secondary" id="toggle-plane-visibility">隐藏</button>
                <button class="step-btn btn-secondary" id="plane-reset">重置</button>
            </div>
        </div>
        <p id="plane-status" class="text-sm text-yellow-400 mb-2"> 请在牙模上点击3个点来定义平面。 </p>
        <div class="guide-text">
            提示：在牙模前牙1/2处及两侧尖牙中1/2处，点击3个点可以更好的定义参考平面
        </div>
    </div>
</div>

    <!-- 步骤2：设计模式选择 (修改后) -->
    <div class="step-section" id="step-2" style="display: none;">
        <div class="step-title cursor-pointer" onclick="toggleStep('step-2-content')">Step 2: 选择绘制模式 ▼</div>
        <div id="step-2-content" class="step-content">
        <div class="step-actions">
            <div id="design-section" class="mb-4 hidden">
                <button class="step-btn btn-secondary" id="mode-manual">自由绘制</button>
                 <button class="step-btn btn-secondary" id="mode-auto" value="smart">智能生成</button>
            </div>
        </div>
        <div class="guide-text">
                手动模式：自由添加点并调整每段路径<br>
                智能模式：基于5个参考点生成平滑曲线
        </div>
    </div>
</div>
    <!-- 修改自由绘制模式面板，添加标题点击展开/收起功能 -->
    <div class="step-section" id="step-2.1" style="display: none;">
    <div class="step-title cursor-pointer" onclick="toggleStep('step-2.1-content')">当前模式: 自由绘制 ▼</div>
    <div id="step-2.1-content" class="step-content">
        <div class="mb-2">
            <label for="design-mode-select" class="text-sm font-medium text-gray-400"> 设计模式: </label>
            <select id="design-mode-select" class="w-full bg-gray-700 border border-gray-600 rounded-md p-1 text-sm text-white mt-1">
                <option value="straight"> 自由绘制 (直线) </option>
                <option value="smooth"> 自由绘制 (平滑) </option>
                <option value="labial_bow"> 唇弓 </option>
            </select>
        </div>
        <span id="diameter-display" class="text-xs text-gray-400"></span>
        <div class="step-actions">
            <button class="step-btn btn-secondary" id="1">开始绘制</button>
            <button class="step-btn btn-secondary" id="2">调整节点</button>
            <button class="step-btn btn-secondary" id="3">删除节点</button>
        </div>
    </div>
</div>
    <!-- 修改智能生成模式面板，添加标题点击展开/收起功能 -->
    <div class="step-section" id="step-2.2" style="display: none;">
    <div class="step-title cursor-pointer" onclick="toggleStep('step-2.2-content')">当前模式: 智能生成 ▼</div>
    <div id="step-2.2-content" class="step-content">
        <div id="auto-mode-params" class="param-controls" style="margin-top: 15px;">
            <p id="status-message" class="text-sm text-yellow-400 mb-2"> 请选择操作模式。 </p>
            <div class="grid grid-cols-2 gap-2">

                <button id="generate-smart" class="col-span-2 bg-purple-600 text-white font-bold py-2 px-4 rounded-md hover:bg-purple-700 transition disabled:opacity-50">
                    生成智能设计
                </button>
            </div>
        </div>
    </div>
</div>
    <div id="export-section" class="mb-4 hidden">
            <h2 class="text-lg font-medium text-gray-300 mb-2"> 4. 导出数据 </h2>
            <div class="flex items-center space-x-3 mb-2">
                <label for="points-count" class="text-sm"> 离散点数: </label>
                <input type="number" id="points-count" value="100" class="w-24 bg-gray-700 border border-gray-600 rounded-md p-1 text-center">
            </div>
            <button id="export-json" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-md hover:bg-green-700 transition disabled:opacity-50" disabled>
                导出为JSON
            </button>
    </div>

  <!-- 帮助弹窗 -->
    <div id="help-modal">
        <div class="help-content">
            <div class="help-title">操作说明</div>

            <div class="help-body">
                <!-- 基础操作部分 -->
                <div class="help-section">
                    <h4>文件管理</h4>
                    <ul>
                        <li><b>加载与导入</b>：点击左上角文件上传图标，可以选择开始新设计，也可导入之前设计并保存好的设计文件。</li>
                        <li><b>保存文件</b>：点击左上角保存图标，可以保存并导出当前设计好的设计文件。</li>
                    </ul>
                </div>

                <!-- 底部操作盘部分 -->
                <div class="help-section">
                    <h4>底部操作盘</h4>
                    <ul>
                        <li><b>样式调整</b>：可以改变牙齿模型和参考平面的透明度，方便对牙模进行编辑。</li>
                        <li><b>参数调整</b>：可以修改弓丝和标记点的直径，以及U型曲的默认宽高。</li>
                        <li><b>视角切换</b>：可以切换模型的视角，包括顶部、底部、左侧、右侧和前面。</li>
                    </ul>
                </div>

                <!-- 设计流程部分 -->
                <div class="help-section">
                    <h4>设置参考平面</h4>
                    <p>在Step1中，点击"调整"按钮，可在牙模上点击3个点定义参考平面，3点放置后可拖动控制点进行微调，完成后点击"确认"完成设置，"重置"可重新选择点定义参考平面。</p>
                </div>

                <!-- 设计模式部分 -->
                <div class="help-section">
                    <h4>设计模式</h4>
                    <p>在Step2中，可以选择手动模式或智能模式。手动模式用于手动创建弓丝路径，智能模式则引导用户标注关键点快速生成唇弓的流程。</p>
                </div>

                <!-- 详细操作模式部分 -->
                <div class="help-section">
                    <h4>手动模式</h4>
                    <ul>
                        <li>点击底部操作盘的<b>"增加节点"或"删除节点"</b>按钮，可在牙齿模型对应位置增加节点或删除已有节点。</li>
                        <li>点击<b>"编辑节点"</b>按钮可拖拽节点来微调节点位置，在此模式下，鼠标悬停于点上光标会变为手形，按住并拖动一个点可在牙模表面移动它。</li>
                        <li>另外<b>Shift+左键单击</b>两个点，后续点击<b>"生成U型曲"</b>按钮，可在对应位置生成U型曲。</li>
                    </ul>
                </div>

                <div class="help-section">
                    <h4>智能模式</h4>
                    <ul>
                        <li>系统将给出提示词提示标记节点，将提示依次<b>在左侧牙模两旁尖牙与第一前磨牙的邻间隙1/2处，左侧尖牙与邻间隙中间向牙龈方向离尖牙3~4毫米处，左侧尖牙1/2处，左侧两颗大门牙缝隙处，右侧尖牙1/2处，右侧尖牙与邻间隙中间向牙龈方向离尖牙3~4毫米处，右侧牙模两旁尖牙与第一前磨牙的邻间隙1/2处</b>进行关键点标记，顺序可倒转进行点击。</li>
                        <li>点击底部操作盘的<b>"删除节点"</b>可删除标记错误位置的关键点，重新对相应关键点进行标记。</li>
                        <li>点击底部操作盘的<b>"编辑节点"</b>按钮可拖拽关键点来微调关键点位置，7个关键点确认位置以后。</li>
                        <li>点击<b>"自动生成"</b>按钮，系统根据关键点特征和位置自动生成U型曲。</li>
                    </ul>
                </div>
            </div>

            <button class="close-help" id="close-help">关闭</button>
        </div>
    </div>


    <!-- 参数设置弹出面板 -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <h3 class="text-xl font-bold mb-4"> 参数设置 </h3>
            <div class="space-y-4">
                <div>
                    <label for="wire-radius-input" class="block text-sm font-medium text-gray-300"> 弓丝直径 (mm) </label>
                    <input type="number" id="wire-radius-input" step="0.1" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div>
                    <label for="marker-radius-input" class="block text-sm font-medium text-gray-300"> 点的直径 (mm) </label>
                    <input type="number" id="marker-radius-input" step="0.1" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                 <div id="uloop-params">
                    <div>
                        <label for="uloop-width-input" class="block text-sm font-medium text-gray-300"> U型曲宽度 (mm) </label>
                        <input type="number" id="uloop-width-input" step="0.5" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div class="mt-4">
                        <label for="uloop-height-input" class="block text-sm font-medium text-gray-300"> U型曲高度 (mm) </label>
                        <input type="number" id="uloop-height-input" step="0.5" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                </div>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="cancel-settings" class="bg-gray-600 text-white font-bold py-2 px-4 rounded-md hover:bg-gray-700 transition"> 取消 </button>
                <button id="save-settings" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition"> 保存 </button>
            </div>
        </div>
    </div>
    </div>
</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';


         // --- 全局参数 ---各种参数
        let wireRadius = 0.4;                // 弓丝的半径（单位：毫米）
        let markerRadius = 0.4;              // 标记点的半径（单位：毫米）
        let uLoopWidth = 4.0;                // U型曲的宽度（单位：毫米）
        let uLoopHeight = 6.0;               // U型曲的高度（单位：毫米）
        const SELECTION_COLOR_EDIT = 0x00ff00;  // 编辑模式下选中点的颜色（绿色）
        const SELECTION_COLOR_ULOOP = 0x9932CC; // U型曲模式下选中点的颜色（紫色）

        let isPanelExpanded = true; // 控制面板展开状态
         // --- 全局变量 ---                         可拖拽点轨道控制器
        let scene, camera, renderer, orbitControls, dragControls;//场景，相机，渲染器，轨道控制器，拖动控制器
         // --- 模型与几何体 ---牙膜对象
        let dentalModel = null, points = [], archCurveObject = null, pointMarkers = [];
        let draggableObjects = []; // All draggable markers
        let uLoopSegments = []; // 存储每个U型曲的元数据
        let smartModePoints = []; // 存储智能模式的7个点
        let smartModeState = 0; // 0:未开始, 1:选择点中, 2:已完成选择
         // --- 模式状态 ---绘制，编辑，平面设置，U型曲线生成
        let isDrawingMode = false, isEditMode = false, isPlaneSetupMode = false, isULoopGenerationMode = false;
        let labialBowControlPoints = [];//唇弓

        let currentModelOpacity = 1.0, currentPlaneOpacity = 0.5; // 透明度状态
         // --- 参考平面变量 ---平面点数组，平面网格，平面拖动控制器，平面法线
        let planeControlPoints = [], referencePlaneMesh = null, planeDragControls = null;
        let planeNormal = new THREE.Vector3(0, 1, 0);


         // --- 交互变量 ---
        let isDraggingView = false;
        let mouseDownPos = new THREE.Vector2();
        let uLoopSelectionIndices = [];//存放被选择u型曲的两个点的索引
        const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();

         // --- 历史记录栈 ---
        let historyStack = [];


         // --- DOM 元素 ---
        const canvas = document.getElementById('mainCanvas');
        const initLoaderInput = document.getElementById('import-btn');
        // 文件操作相关
        const stlLoaderInput = document.getElementById('stl-loader');      // STL文件加载输入
        const jsonImporterInput = document.getElementById('json-importer'); // JSON导入输入
        // UI部分容器
        const planeSetupSection = document.getElementById('plane-setup-section'); // 参考平面设置区域
        const designSection = document.getElementById('design-section');         // 唇弓设计区域
        const exportSection = document.getElementById('export-section');         // 数据导出区域
        // 按钮和控制元素
        const setupPlaneModeBtn = document.getElementById('plane-adjust'); // 进入平面设置模式按钮
        const confirmPlaneBtn = document.getElementById('plane-confirm');      // 确认平面按钮
        const planeStatus = document.getElementById('plane-status');           // 平面状态显示文本
        const toggleDrawModeBtn = document.getElementById('toggle-draw-mode'); // 切换绘制模式按钮
        const toggleEditModeBtn = document.getElementById('toggle-edit-mode'); // 切换编辑模式按钮
        const generateULoopBtn = document.getElementById('generate-uloop');    // 生成U型曲按钮
        const clearDrawingBtn = document.getElementById('clear-drawing');      // 清除绘制按钮
        const navExportJsonBtn = document.getElementById('nav-export-json');
        const exportJsonBtn = document.getElementById('export-json');          // 导出JSON按钮
        const statusMessage = document.getElementById('status-message');       // 状态消息显示区域
        const loaderSpinner = document.getElementById('loader');               // 加载动画
        // 设置面板相关
        const settingsModal = document.getElementById('settings-modal');       // 设置模态框
        const paramAdjustBtn = document.getElementById('param-adjust');      // 参数调整按钮
        const saveSettingsBtn = document.getElementById('save-settings');      // 保存设置按钮
        const cancelSettingsBtn = document.getElementById('cancel-settings');  // 取消设置按钮
        const wireRadiusInput = document.getElementById('wire-radius-input');  // 弓丝半径输入
        const markerRadiusInput = document.getElementById('marker-radius-input'); // 标记点半径输入
        const uloopParamsDiv = document.getElementById('uloop-params');        // U型曲参数区域
        const uloopWidthInput = document.getElementById('uloop-width-input');  // U型曲宽度输入
        const uloopHeightInput = document.getElementById('uloop-height-input'); // U型曲高度输入
        const diameterDisplay = document.getElementById('diameter-display');   // 直径显示区域
        const togglePlaneVisibilityBtn = document.getElementById('toggle-plane-visibility');

        const brightnessSlider = document.getElementById('scene-brightness');
            const brightnessValueDisplay = document.getElementById('scene-brightness-value');
            // 初始化显示值
            brightnessValueDisplay.textContent = '1.5';

            // 滑条变化时更新光源强度
            brightnessSlider.addEventListener('input', () => {
                // 将滑块值（1-30）转换为亮度值（0.1-3.0）
                const brightness = parseFloat((brightnessSlider.value / 10).toFixed(1));
                // 更新两个方向光的强度
                directionalLight_right.intensity = brightness;
                directionalLight_left.intensity = brightness;
                // 更新显示文本
                brightnessValueDisplay.textContent = brightness;
            });
        // 其他功能
        const undoBtn = document.getElementById('undo-action');           // 撤销按钮
        const designModeSelect = document.getElementById('mode-auto'); // 设计模式选择下拉菜单

        const opacitySlider = document.getElementById('model-opacity');  // 透明度滑块
        //清除所有（包括触参考平面）按钮事件
        document.getElementById('reset-all').addEventListener('click', resetAll);
        //使得初始导入窗口可以被关闭
        document.getElementById('close-modal').addEventListener('click', () => {
                document.getElementById('initial-modal').style.display = 'none';
                if (!dentalModel) disablePageInteraction(); // 未导入模型则保持禁用
            });
        // 控制面板事件收放
        document.getElementById('panel-toggle').addEventListener('click', togglePanel);
        // 设计模式选择
        document.getElementById('mode-manual').addEventListener('click', () => setDesignMode('manual'));
        document.getElementById('mode-auto').addEventListener('click', () => setDesignMode('auto'));


        function setupDragControls() {  //鼠标拖动点的函数---控制器
            if (dragControls) {
                dragControls.dispose();
            }//如果已经有拖动控制器了，就先销毁它
            dragControls = new DragControls(draggableObjects, camera, renderer.domElement);
             //创建新的控制器，draggableObjects是所有可拖动的点对象，camera和渲染器的DOM元素，两者绑定
                                           //监听拖动事件,拖动开始
            dragControls.addEventListener('dragstart', function (event) {
                orbitControls.enabled = false;//拖动开始时禁用轨道控制器
                 // 设置点的颜色以指示它正在被拖动
                event.object.material.color.set(SELECTION_COLOR_EDIT);//SELECTION_COLOR_EDIT = 0x00ff00;颜色已设置
                const index = event.object.userData.index;
                const pointData = points[index].userData;
                if (pointData && pointData.type === 'uloop') {
                    saveState();
                    const uLoop = findULoopByPointIndex(index);

                    if (uLoop) {
                        uLoop.isRotating = true;

                        // 确保旋转轴是最新的
                        const startTop = points[uLoop.startTopIndex];
                        const endTop = points[uLoop.endTopIndex];
                        uLoop.rotationAxis = new THREE.Vector3()
                            .subVectors(endTop, startTop)
                            .normalize();

                        // 保存所有半圆点的原始位置用于刚性旋转
                        uLoop.originalPoints = {};
                        uLoop.allSemicirclePointIndices.forEach(pointIndex => {
                            if (pointIndex < points.length) {
                                uLoop.originalPoints[pointIndex] = points[pointIndex].clone();
                            }
                        });
                    }
                }
            });

              //监听拖动事件,拖动中
            dragControls.addEventListener('drag', function (event) {
                const index = event.object.userData.index;
                const pointData = points[index].userData;
                const uLoop = findULoopByPointIndex(index);

                if (pointData && pointData.type === 'uloop') {
                    if (pointData.role === 'start_top' || pointData.role === 'end_top') {
                        // 拖动顶部点时，实时同步数据层与界面层
                        points[index].copy(event.object.position);
                    } else if (pointData.role === 'mid' && uLoop && uLoop.isRotating) {
                        // 中点拖动时，执行刚性旋转
                        rotateSemicircleAsRigidBody(uLoop, event.object.position);
                    }
                } else {
                    // 普通点拖动逻辑
                    points[index].copy(event.object.position);
                }

                // 实时刷新弓丝
                updateArchCurve();
            });

                                       //监听拖动事件,拖动结束
            dragControls.addEventListener('dragend', function (event) {
                orbitControls.enabled = true;
                const index = event.object.userData.index;
                const pointData = points[index].userData;
                const uLoop = findULoopByPointIndex(index);

                // 关键新增：若松开的是start_top/end_top，执行校正逻辑
                if (pointData && pointData.type === 'uloop' && (pointData.role === 'start_top' || pointData.role === 'end_top') && uLoop) {
                    saveState(); // 校正前保存状态，支持撤销
                    correctULoopAfterDrag(uLoop); // 执行校正
                }

                // 恢复颜色逻辑
                if (pointData && pointData.type === 'uloop') {
                    if (pointData.role === 'mid') {
                        event.object.material.color.set(0x00FF00); // 绿色
                        if (uLoop) {
                            uLoop.isRotating = false;
                            delete uLoop.originalPoints; // 清理临时数据
                        }
                    } else if (pointData.role === 'start_top' || pointData.role === 'end_top') {
                        event.object.material.color.set(0xFFA500); // 橙色
                    } else {
                        event.object.material.color.set(0x9932CC); // 紫色
                    }
                } else if (uLoopSelectionIndices.includes(index)) {
                    event.object.material.color.set(SELECTION_COLOR_ULOOP);
                } else {
                    event.object.material.color.set(0xff0000);
                }
            });
        }

        function init() {
            //初始化场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a3b4c);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 150);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight_right = new THREE.DirectionalLight(0xffffff, 1.5);
            const directionalLight_left = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight_right.position.set(50, 50, 100);
            directionalLight_left.position.set(50, -50, -100); //加多一束光
            scene.add(directionalLight_right);
            scene.add(directionalLight_left);



            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = false;

            initStyleAdjust();
            setupDragControls();


            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            //为画布加上点击事件
            canvas.addEventListener('mousedown', onCanvasMouseDown, true); // Use capture phase
            canvas.addEventListener('mousemove', onCanvasMouseMove, false);
            canvas.addEventListener('mouseup', onCanvasMouseUp, false);
            window.addEventListener('keydown', (event) => {
                if (event.ctrlKey && (event.key === 'z' || event.key === 'Z')) {
                    undo();
                }
            });
            initLoaderInput.addEventListener('click', showLoaderWindow);
            stlLoaderInput.addEventListener('change', loadSTL);
            jsonImporterInput.addEventListener('change', importJSON);
            setupPlaneModeBtn.addEventListener('click', togglePlaneSetupMode);
            confirmPlaneBtn.addEventListener('click', confirmPlane);
            toggleDrawModeBtn.addEventListener('click', () => setMode(isDrawingMode ? 'none' : 'draw'));
            toggleEditModeBtn.addEventListener('click', () => setMode(isEditMode ? 'none' : 'edit'));
            generateULoopBtn.addEventListener('click', generateULoopFromSelection);
            clearDrawingBtn.addEventListener('click', clearDrawing);
            exportJsonBtn.addEventListener('click', exportJSON);
            navExportJsonBtn.addEventListener('click', exportJSON);

            paramAdjustBtn.addEventListener('click', showSettingsModal);
            saveSettingsBtn.addEventListener('click', saveSettings);
            cancelSettingsBtn.addEventListener('click', hideSettingsModal);
            togglePlaneVisibilityBtn.addEventListener('click', togglePlaneVisibility);

            undoBtn.addEventListener('click', undo);
            designModeSelect.addEventListener('change', onDesignModeChange);
            document.getElementById('generate-smart').addEventListener('click', generateSmartDesign);
            initViewSwitcher();
            updateDiameterDisplay();
            animate();
            // 添加步骤内容样式
        const style = document.createElement('style');
        style.textContent = `
            .step-content {
                margin-top: 10px;
                padding-left: 5px;
            }
            .step-title {
                font-weight: bold;
                margin-top: 15px;
            }
            .cursor-pointer {
                cursor: pointer;
            }
        `;
        document.head.appendChild(style);
        }

        //导入模型界面
        function showLoaderWindow(){
            document.getElementById('import-btn').addEventListener('click', () => {
                document.getElementById('initial-modal').style.display = 'flex';
            });
            document.getElementById('close-modal').addEventListener('click', () => {
                document.getElementById('initial-modal').style.display = 'none';
                if (!dentalModel) disablePageInteraction(); // 未导入模型则保持禁用
            });
        }
        function loadSTL(event) {//加载stl文件
            const file = event.target.files[0];//获取文件对象
            if (!file) return;
            loaderSpinner.classList.remove('hidden');//显示加载动画

            if (dentalModel) scene.remove(dentalModel);//如果已有牙模，先移除
            planeControlPoints.forEach(p => scene.remove(p));//移除参考平面的控制点
            planeControlPoints = [];//清空参考平面控制点数组
            if (referencePlaneMesh) scene.remove(referencePlaneMesh);
            referencePlaneMesh = null;
            confirmPlaneBtn.disabled = true;//禁用确认平面按钮
            togglePlaneVisibilityBtn.disabled = true;//禁用隐藏平面按钮
            //还没有点击三个点定义平面
            clearDrawing();//清除已有的点和曲线
            historyStack = [];//清空历史记录栈
            undoBtn.disabled = true;//禁用撤销按钮

            //读取文件内容
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const geometry = new STLLoader().parse(e.target.result);
                    geometry.center();
                    geometry.computeVertexNormals();
                    const material = new THREE.MeshStandardMaterial({
                        color: 0xeaeaea,
                        metalness: 0.1,
                        roughness: 0.6,
                        transparent: true
                    });
                    dentalModel = new THREE.Mesh(geometry, material);
                    dentalModel.rotation.x = -Math.PI / 2;
                    scene.add(dentalModel);

                    // 更新导入界面状态，不显示
                    document.getElementById('initial-modal').style.display = 'none';

                    loaderSpinner.classList.add('hidden');
                    opacitySlider.value = 1;

                    planeSetupSection.classList.remove('hidden');//显示设置参考平面模块,2.设置参考平面部分
                    togglePlaneSetupMode();//进入平面设置模式
                }catch (error) {
                    console.error('STL加载失败:', error);
                }
            };
            reader.readAsArrayBuffer(file);//读取文件内容
        }


        // --- History Management (Undo) ---//当前状态所有点信息
        function saveState() {//保存当前状态以便撤销
            const state = {//创建一个状态对象,相当于数组列表，第一个数组是points，第二个数组是labialBowControlPoints
                // Deep clone points with their userData
                points: points.map(p => {//map函数返回一个新数组
                    const newP = p.clone();
                    if (p.userData) {
                        // Simple object copy is fine here
                        newP.userData = { ...p.userData };//userData是点的附加信息
                    }
                    return newP;//返回克隆后的点，点的userData也被克隆，整个点对象被克隆
                }),
                labialBowControlPoints: labialBowControlPoints.map(p => p.clone()),//唇弓设计模式下的点也被克隆
                uLoopSegments: JSON.parse(JSON.stringify(uLoopSegments))
            };
            historyStack.push(state);
            undoBtn.disabled = false;//启用撤销按钮
        }

        function undo() {//撤销回上一步操作
            if (historyStack.length === 0) return;
            const prevState = historyStack.pop();

            // Re-clone from the state to prevent mutation issues返回上一个状态
            points = prevState.points.map(p => {
                const newP = p.clone();
                if (p.userData) {
                    newP.userData = { ...p.userData };
                }
                return newP;
            });
            labialBowControlPoints = prevState.labialBowControlPoints.map(p => p.clone());
            uLoopSegments = JSON.parse(JSON.stringify(prevState.uLoopSegments));
            undoBtn.disabled = historyStack.length === 0;//如果历史记录栈为空，禁用撤销按钮
            deselectAllPoints();//清空所有选择点，按撤销以后，自由绘制中已选择u型曲的点会被清空

            if (designModeSelect.value === 'labial_bow' && typeof constructLabialBow === 'function') {
                constructLabialBow();//唇弓设计模式下，撤销后重新构建唇弓,这个函数没有实现
            } else {//所有设计模式撤销最后一步，重新绘制
                redrawScene();//已有的点改变，重新绘制场景，先消除原来的点场景和可拖拽对象，再根据points数组重新创建点和曲线
            }
        }

        // --- Settings Modal Logic ---
        function showSettingsModal() {//监听参数设置按钮
            wireRadiusInput.value = (wireRadius * 2).toFixed(2);//内部用的是半径存储计算，显示用的是直径，toFixed(2)保留两位小数
            markerRadiusInput.value = (markerRadius * 2).toFixed(2);
            uloopWidthInput.value = uLoopWidth;
            uloopHeightInput.value = uLoopHeight;
            settingsModal.classList.remove('hidden');//显示参数设置弹窗,参数设置按钮dom元素
        }

        function hideSettingsModal() {//监听取消按钮
            settingsModal.classList.add('hidden');//隐藏参数设置弹窗
        }

        function saveSettings() {//监听参数保存按钮 // 读取并验证输入值
            const newWireDiameter = parseFloat(wireRadiusInput.value);//设置新值，有字符转化为数字
            const newMarkerDiameter = parseFloat(markerRadiusInput.value);
            const newULoopWidth = parseFloat(uloopWidthInput.value);
            const newULoopHeight = parseFloat(uloopHeightInput.value);


            if (!isNaN(newWireDiameter) && newWireDiameter > 0) wireRadius = newWireDiameter / 2;
            if (!isNaN(newMarkerDiameter) && newMarkerDiameter > 0) markerRadius = newMarkerDiameter / 2;//弓丝和标记点的半径，内部使用半径计算
            if (!isNaN(newULoopWidth) && newULoopWidth > 0) uLoopWidth = newULoopWidth;
            if (!isNaN(newULoopHeight) && newULoopHeight > 0) uLoopHeight = newULoopHeight;

            updateDiameterDisplay();//更新显示弓丝直径
            redrawScene();//重新绘制场景，更新点和曲线的大小
            hideSettingsModal();//保存以后关闭参数设置弹窗
        }

        function updateDiameterDisplay() {//就是那一行字
            diameterDisplay.textContent =  `弓丝直径:  ${(wireRadius * 2).toFixed(2)} mm`;//显示弓丝直径，旁边有一个参数改变的按钮
        }


        // --- Mode Management ---
        function onDesignModeChange() {//设置模式选择，监听设计模式下拉菜单,那些按钮需要显示隐藏可以根据设计模式来
            clearDrawing();//切换模式时清除所有当前绘制
            const designMode = designModeSelect.value;//dom元素,设计模式下拉菜单
            generateULoopBtn.style.display = (designMode === 'straight' || designMode === 'smooth') ? 'block' : 'none';
            // 智能模式特殊处理
            if (designMode === 'smart') {
                statusMessage.textContent = '智能模式：请按顺序选择7个点(1.左侧端点, 2.左侧方向点, 3.左侧尖牙, 4.中切牙, 5.右侧尖牙, 6.右侧方向点, 7.右侧端点) - 端点将自动生成延伸弓丝';
                setMode('draw');
            } else {
                setMode('draw');
            }
        }
        // 重置智能模式状态
        function setMode(mode) {//同时监听绘制和编辑按钮

            if (mode !== 'draw' || designModeSelect.value !== 'smart') {
                smartModePoints = [];
                smartModeState = 0;
            }

            // 如果是智能模式且切换到绘制模式
            if (designModeSelect.value === 'smart' && mode === 'draw') {
                smartModeState = 1;
                statusMessage.textContent = '智能模式：请按顺序选择7个点';
                // 显示生成按钮
                document.getElementById('generate-smart').classList.remove('hidden');
            }

            isDrawingMode = mode === 'draw';
            isEditMode = mode === 'edit';
            isPlaneSetupMode = mode === 'plane';
            //在模型上的操作有三种模式，绘制，编辑，平面设置，全局变量改变知道当前模式就知道如何绘制
            //在上方设置监听事件那看出点击两次同一个按钮会取消该模式
            toggleDrawModeBtn.classList.remove('bg-yellow-600', 'bg-gray-600');//开始绘制按钮dom
            toggleEditModeBtn.classList.remove('bg-green-600', 'bg-gray-600');//编辑点按钮dom

            if (isDrawingMode) {
                toggleDrawModeBtn.classList.add('bg-yellow-600');
                statusMessage.textContent =  '绘制模式：单击牙模添加点。' ;
            } else if (isEditMode) {
                toggleEditModeBtn.classList.add('bg-green-600');
                statusMessage.textContent =  '编辑模式：拖动点修改，Shift+单击选择点。' ;
            } else {
                toggleDrawModeBtn.classList.add('bg-gray-600');
                toggleEditModeBtn.classList.add('bg-gray-600');
                statusMessage.textContent = '请选择操作模式。';
            }
            deselectAllPoints();//清空所有u型生成选择点
        }

        function clearDrawing() {//监听清除全部按钮，清除所有点和曲线，重置状态
            if (points.length > 0) saveState();//保存当前状态以便撤销，清除全部点以后依旧能撤销返回上一状态
            points = [];
            labialBowControlPoints = [];

            pointMarkers.forEach(marker => scene.remove(marker));//移除所有点的球体对象
            pointMarkers = [];
            draggableObjects = [];

            if(dragControls) dragControls.dispose();//销毁拖动控制器
            setupDragControls();//重新创建拖动控制器

            if (archCurveObject) scene.remove(archCurveObject);//移除主曲线对象
            archCurveObject = null;


            exportJsonBtn.disabled = true;//禁用导出按钮
            generateULoopBtn.disabled = true;//禁用生成u型曲按钮
            if (!designSection.classList.contains('hidden')) {//设计部分显示时,设置唇弓那一整部分designSection
                setMode('none');//所有模式都不启用，设置所有模式变量为false，绘制编辑
            }//点击清除全部按钮以后且设计部分显示时，所有模式都不启用
            updateArchCurve();//更新曲线显示，保持数据同步
        }


        //监听调整平面按钮
        function togglePlaneSetupMode() {
            setMode('plane');//进入平面设置模式
            planeStatus.textContent =  `请在牙模上点击  ${3 - planeControlPoints.length}  个点来定义平面。` ;
            if (planeControlPoints.length === 3) {
                 planeStatus.textContent =  '请拖动控制点调整平面，或点击“确认平面”。' ;
            }

            designSection.classList.add('hidden');//隐藏3.设计唇弓部分，看成一整个模块，弄成dom元素
            exportSection.classList.add('hidden');//隐藏4.导出部分
            //当在绘制或调整点的时候，点击调整平面按钮，隐藏可拖拽点和主曲线
             // Hide draggable points and show plane control points隐藏可拖拽点，显示平面控制点
            draggableObjects.forEach(p => p.visible = false);
            if (archCurveObject) archCurveObject.visible = false;

            // Show plane control points and reference plane显示平面控制点和平面
            planeControlPoints.forEach(p => p.visible = true);
            if (referencePlaneMesh) {//平面网格，显示以后按钮转为隐藏平面
                referencePlaneMesh.visible = true;

            }

            if (dragControls) dragControls.dispose();//把点的拖动控制器销毁,避免与平面控制点冲突
            // Setup drag controls for plane control points设置平面控制点的拖动控制器
            planeDragControls = new DragControls(planeControlPoints, camera, renderer.domElement);
            planeDragControls.addEventListener('dragstart', () => {
                orbitControls.enabled = false;
            });
            planeDragControls.addEventListener('drag', updateReferencePlane);
            planeDragControls.addEventListener('dragend', () => {
                orbitControls.enabled = true;
            });
        }

        function addPlaneControlPoint(position) {//添加平面控制点
            if (planeControlPoints.length >= 3) return;
            const geometry = new THREE.SphereGeometry(0.4, 32, 32);//控制点球体的大小
            const material = new THREE.MeshBasicMaterial({ color: 0x00FFFF });
            const point = new THREE.Mesh(geometry, material);
            point.position.copy(position);
            scene.add(point);//把点加到场景
             // Store index for potential future use存储索引以备将来使用
            planeControlPoints.push(point);
            planeStatus.textContent =  `请在牙模上点击  ${3 - planeControlPoints.length}  个点来定义平面。` ;

            if (planeControlPoints.length === 3) {
                updateReferencePlane();//更新参考平面
                confirmPlaneBtn.disabled = false;//启用确认平面按钮
                planeStatus.textContent =  '平面已定义。可拖动控制点调整，或点击“确认平面”。' ;
            }
        }

        function updateReferencePlane() {//参考平面更新绘制，更新操作
            if (planeControlPoints.length < 3) return;
            const [p1, p2, p3] = planeControlPoints.map(p => p.position);//获取平面的三个控制点
            const plane = new THREE.Plane().setFromCoplanarPoints(p1, p2, p3);//三点创建平面对象
            planeNormal.copy(plane.normal);//平面的法向量
            if (!referencePlaneMesh) {//如果没有参考平面网格
                const planeGeom = new THREE.PlaneGeometry(200, 200);//200*200的平面几何体
                const planeMat = new THREE.MeshStandardMaterial({ color: 0x00FFFF, opacity: 0.3, transparent: true, side: THREE.DoubleSide });
                referencePlaneMesh = new THREE.Mesh(planeGeom, planeMat);
                scene.add(referencePlaneMesh);
            }
            referencePlaneMesh.position.copy(p1);//平面的位置由第一个控制点的位置代表
            referencePlaneMesh.lookAt(p1.clone().add(plane.normal));//平面的方向由第一个控制点的位置加上法向量代表
        }

        function confirmPlane() {//监听确认平面按钮
            isPlaneSetupMode = false;
            planeControlPoints.forEach(p => p.visible = false);
            if (planeDragControls) planeDragControls.dispose();//平面控制点的拖动控制器销毁
            setupDragControls();//重新设置点的拖动控制器
            document.getElementById('step-2').style.display = 'block'; // 显示下一步

            designSection.classList.remove('hidden');
            exportSection.classList.remove('hidden');
            draggableObjects.forEach(p => p.visible = true);
            if (archCurveObject) archCurveObject.visible = true;
            togglePlaneVisibilityBtn.disabled = false;//启用隐藏平面按钮
            planeStatus.textContent =  '参考平面已确认。' ;
            setMode('draw');
            document.getElementById('step-2').style.display = 'block';
    document.getElementById('step-2-content').style.display = 'block';
    document.getElementById('step-2').querySelector('.step-title').innerHTML = 'Step 2: 选择绘制模式 ▼';
        }

        //监听隐藏平面按钮
        function togglePlaneVisibility() {
            if (referencePlaneMesh) {
                referencePlaneMesh.visible = !referencePlaneMesh.visible;
                togglePlaneVisibilityBtn.textContent = referencePlaneMesh.visible ?  '隐藏'  :  '显示' ;
            }
        }

        // canvas画布上的鼠标点击事件，定位点的位置利用射线投射技术
        function onCanvasMouseDown(event) {//
            if (event.button !== 0) return;//只监听左键点击,鼠标点击，0代表左键，1代表中键，2代表右键

            //编辑模式中shift键和点击左键同时，点击后增加u型选择点
            if (isEditMode && event.shiftKey) {//编辑模式中shift键和点击左键同时
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;//将屏幕坐标转换为Three.js，点击开始的位置
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);//相机发出射线，往当前鼠标位置发射
                const intersects = raycaster.intersectObjects(draggableObjects);//该射线与所有可拖动对象的交点

                if (intersects.length > 0) {//如果点击空白处，清除所有u型选择点，颜色改回去
                    handleULoopSelection(intersects[0].object);//距离射线最近的点的可拖拽对象
                } else {
                    deselectAllPoints();
                }
                event.stopImmediatePropagation();//将U型环选择操作与其他可能的鼠标事件处理逻辑完全隔离
                return;
            }

            isDraggingView = false;
            mouseDownPos.set(event.clientX, event.clientY);
        }

        function onCanvasMouseMove(event) {//鼠标移动中
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;//将鼠标点击屏幕坐标转换为three.js坐标
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (event.buttons !== 1) return;//左键按下
            if (mouseDownPos.distanceTo(new THREE.Vector2(event.clientX, event.clientY)) > 5) {
                isDraggingView = true;//如果鼠标移动距离大于5像素，认为是拖动视图
            }
        }

        function onCanvasMouseUp(event) {
            if (event.button !== 0) return;
            if (isDraggingView) {
                isDraggingView = false;
                return;
            }
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isPlaneSetupMode) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(dentalModel);
                if (intersects.length > 0) {
                    addPlaneControlPoint(intersects[0].point);
                }
                return;
            }

            if (isDrawingMode) {
                addPointAtCursor();
            }
        }

        // --- 修改 addPointAtCursor 函数中的智能模式提示 ---//
        function addPointAtCursor() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(dentalModel);

            if (intersects.length > 0) {
                // 智能模式特殊处理
                if (designModeSelect.value === 'smart' && smartModeState === 1) {
                    if (smartModePoints.length < 7) {
                        saveState();
                        const centerlinePoint = getOffsetPoint(intersects[0]);
                        smartModePoints.push(centerlinePoint);
                        points.push(centerlinePoint);

                        // 更新状态提示
                        const pointsNeeded = 7 - smartModePoints.length;

                        // 根据当前点数给出更明确的提示
                        let pointDescription = "";
                        switch (smartModePoints.length) {
                            case 1:
                                pointDescription = "左侧端点（将自动生成延伸弓丝）";
                                break;
                            case 2:
                                pointDescription = "左侧方向点（用于确定U型曲方向）";
                                break;
                            case 3:
                                pointDescription = "左侧尖牙";
                                break;
                            case 4:
                                pointDescription = "中切牙";
                                break;
                            case 5:
                                pointDescription = "右侧尖牙";
                                break;
                            case 6:
                                pointDescription = "右侧方向点（用于确定U型曲方向）";
                                break;
                            case 7:
                                pointDescription = "右侧端点（将自动生成延伸弓丝）";
                                break;
                        }

                        if (pointsNeeded > 0) {
                            statusMessage.textContent = `还需选择 ${pointsNeeded} 个点 - 当前：${pointDescription}`;
                        } else {
                            statusMessage.textContent = '点选择完成，点击"生成智能设计"按钮';
                            smartModeState = 2;
                        }

                        redrawScene();
                    }
                    return;
                }

                // 原有逻辑
                saveState();
                const centerlinePoint = getOffsetPoint(intersects[0]);
                points.push(centerlinePoint);
                redrawScene();
            }
        }

        function redrawScene() {
            //从新绘制点，曲线，包括点标记和可拖拽对象，包括点显示
            // Clean up old markers
            //每次加点、删点、撤销、自动生成等操作后，调用 redrawScene，让界面和数据保持一致。
            //保证所有点都能正确显示、拖动，曲线实时更新
            pointMarkers.forEach(marker => scene.remove(marker));//移除旧的点标记，场景里消失
            pointMarkers = [];//清空绘制显示点的球体对象数组
            draggableObjects = [];//可拖拽对象数组清空


            // Recreate markers based on the current points array
            points.forEach((p, i) => {
                // 确保自动生成的表面点也可见
                if (p.userData && p.userData.generated) {
                    p.userData.isULoopInternal = false; // 确保不是内部点
                }
                addPointMarker(p, i);
            });//根据当前点数组重新创建标记，更新可拖拽对象数组
             // Update drag controls with the new set of draggable objects

            updateArchCurve();//更新曲线
            setupDragControls(); // Re-setup drag controls for the new set of draggable objects
            //为新的可拖拽对象重新设置拖拽控制器
        }

        function addPointMarker(position, index) {//为点添加可视化标记，相当于添加pointMarkers和draggableObjects用于显示和拖拽
            const isULoopInternal = position.userData && position.userData.isULoopInternal;
            const isAutoSurface = position.userData && position.userData.generated;

            const markerGeometry = new THREE.SphereGeometry(markerRadius, 16, 16);
            const isSelectedForULoop = uLoopSelectionIndices.includes(index);

            let color;
            if (position.userData?.type === 'uloop') {
                if (position.userData.role === 'mid') {
                    color = 0x00FF00; // 中点绿色
                } else if (position.userData.role === 'start_top' || position.userData.role === 'end_top') {
                    color = 0xFFA500; // 顶部点橙色
                } else {
                    color = 0x9932CC; // 其他U型曲点紫色
                }
            } else if (isAutoSurface) {
                color = 0x00BFFF; // 自动生成的表面点使用天蓝色
            } else {
                color = isSelectedForULoop ? SELECTION_COLOR_ULOOP : 0xff0000;
            }

            const markerMaterial = new THREE.MeshBasicMaterial({ color: color });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            //创建点的几何体和材质，颜色根据是否被选择为u型曲线点而定，pointMarkers是红色，选择u型曲线点是紫色
            marker.position.copy(position);//球体位置为当前点坐标

            // Preserve the point's userData in the marker's userData
            marker.userData = { ...(position.userData || {}), index: index };

            if (!marker.userData.type) {
                marker.userData.type = 'normal';
            }


            scene.add(marker);//把球体添加到场景
            pointMarkers.push(marker); // Keep all markers for easy cleanup，现有所有点的pointMarkers数组


            // Only make it visible and draggable if it's not a hidden U-loop point
            if (isULoopInternal) {//u型曲线内部点，不显示也不可拖拽
                marker.visible = false;
            } else {
                draggableObjects.push(marker);
            }
        }

        function updateArchCurve() {//根据点数组更新曲线
            if (archCurveObject) {//如果存在曲线对象，先移除旧的曲线对象
                scene.remove(archCurveObject);
                archCurveObject.geometry.dispose();//释放旧的几何体
                archCurveObject.material.dispose();//释放旧的材质
                archCurveObject = null;//曲线对象设为null,确保不会出现内存泄漏
            }


            const currentPoints = points;
            const hasEnoughPoints = currentPoints.length >= 2;
            exportJsonBtn.disabled = !hasEnoughPoints;//如果点数组长度小于2，禁用导出按钮

            if (hasEnoughPoints) {//有两个点及以上可以画曲线
                const designMode = designModeSelect.value;
                let curve;

                if (designMode === 'smooth' || designMode === 'labial_bow' || designMode === 'smart') {
                    //生成平滑过渡的曲线路径，根据全局点数组
                     curve = new THREE.CatmullRomCurve3(currentPoints, false, 'catmullrom', 0.5);
                } else { // 'straight'
                    const curvePath = new THREE.CurvePath();
                    for (let i = 0; i < currentPoints.length - 1; i++) {
                        const lineCurve = new THREE.LineCurve3(currentPoints[i], currentPoints[i+1]);//生成直线路径
                        curvePath.add(lineCurve);
                    }
                    curve = curvePath;
                }

                if (curve) {//如果有路径，画线
                    const tubeGeometry = new THREE.TubeGeometry(curve, 256, wireRadius, 12, false);
                    const tubeMaterial = new THREE.MeshStandardMaterial({ color: 0x00bfff, metalness: 0.5, roughness: 0.2, emissive: 0x112233 });
                    archCurveObject = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    scene.add(archCurveObject);
                }
            }
        }

        function createSmoothCurvePoints(points, divisions = 20) {
            if (points.length < 2) return points;
            const curve = new THREE.CatmullRomCurve3(points);
            return curve.getPoints(points.length * divisions);
        }

        function getOffsetPoint(intersect) {
            if (!intersect || !intersect.point || !intersect.face) {
                console.warn('无效的交点数据');
                return new THREE.Vector3(0, 0, 0);
            }

            const point = intersect.point.clone();
            const normal = intersect.face.normal.clone();

            // 转换法线到世界坐标
            normal.transformDirection(dentalModel.matrixWorld);
            normal.normalize();

            const offsetPoint = point.clone().add(normal.multiplyScalar(wireRadius));
            return offsetPoint;
        }

         // --- U-Loop Functions ---
                //直线模式下
        function generateULoopFromSelection() {
            if (uLoopSelectionIndices.length !== 2) return;
            saveState();

            const [index1, index2] = uLoopSelectionIndices.sort((a, b) => a - b);
            const p_start = points[index1];
            const p_end = points[index2];

            const p_mid_ref = (index2 - index1 > 1) ? points[Math.floor((index1 + index2) / 2)] : null;

            const x_hat = new THREE.Vector3().subVectors(p_end, p_start).normalize();
            let y_hat;

            if (p_mid_ref) {
                statusMessage.textContent = "使用三点共面为U型曲定向。";
                const v1m = new THREE.Vector3().subVectors(p_mid_ref, p_start);
                const v_perp = v1m.clone().sub(x_hat.clone().multiplyScalar(v1m.dot(x_hat)));
                y_hat = (v_perp.lengthSq() < 0.0001) ? new THREE.Vector3().crossVectors(x_hat, planeNormal).normalize() : v_perp.normalize();

                const curveMidpoint = p_start.clone().lerp(p_end, 0.5);
                const outVector = new THREE.Vector3().subVectors(p_mid_ref, curveMidpoint);
                if (y_hat.dot(outVector) < 0) {
                    y_hat.negate();
                }
            } else {
                statusMessage.textContent = "注意: 使用参考平面为U型曲定向。";
                y_hat = new THREE.Vector3().crossVectors(x_hat, planeNormal).normalize();
            }

            const uLoopGeometry = generateULoopGeometry(p_start, p_end, y_hat, uLoopHeight, index1, index2);

            const pointsToRemove = index2 - index1 - 1;
            points.splice(index1 + 1, pointsToRemove, ...uLoopGeometry);

            deselectAllPoints();
            redrawScene();
        }
                //智能
        function generateULoopGeometry(baseStart, baseEnd, y_hat, height, index1, index2) {
            // 确保y_hat与x_hat垂直
            const x_hat = new THREE.Vector3().subVectors(baseEnd, baseStart).normalize();
            const dot = x_hat.dot(y_hat);
            if (Math.abs(dot) > 0.1) {
                y_hat.sub(x_hat.clone().multiplyScalar(dot)).normalize();
            }
            const z_hat = new THREE.Vector3().crossVectors(x_hat, y_hat).normalize();
            const armTopStart = baseStart.clone().add(y_hat.clone().multiplyScalar(height));
            const armTopEnd = baseEnd.clone().add(y_hat.clone().multiplyScalar(height));

            const loopPoints = [];

            // Point 1: Semicircle Start (Visible)
            const startTopPoint = armTopStart.clone();
            startTopPoint.userData = {
                type: 'uloop',
                role: 'start_top',
                baseIndex: index1 // 使用起始点索引作为baseIndex
            };
            loopPoints.push(startTopPoint);

            const semicircleCenter = armTopStart.clone().lerp(armTopEnd, 0.5);
            const startVec = new THREE.Vector3().subVectors(armTopStart, semicircleCenter);
            const radius = startVec.length();

            const numSemicirclePoints = 16;
            const midPointIndex = Math.floor(numSemicirclePoints / 2);

            for (let i = 1; i < numSemicirclePoints; i++) {
                const angle = -Math.PI * (i / numSemicirclePoints);
                const point = new THREE.Vector3().copy(startVec).applyAxisAngle(z_hat, angle).add(semicircleCenter);

                if (i === midPointIndex) {
                    point.userData = {
                        type: 'uloop',
                        role: 'mid',
                        baseIndex: index1 // 使用起始点索引作为baseIndex
                    };
                } else {
                    point.userData = {
                        isULoopInternal: true,
                        type: 'uloop',
                        role: 'internal',
                        baseIndex: index1 // 使用起始点索引作为baseIndex
                    };
                }
                loopPoints.push(point);
            }

            // Point 3: Semicircle End (Visible)
            const endTopPoint = armTopEnd.clone();
            endTopPoint.userData = {
                type: 'uloop',
                role: 'end_top',
                baseIndex: index1 // 使用起始点索引作为baseIndex（保持一致）
            };
            loopPoints.push(endTopPoint);

            return loopPoints;
        }

                //半圆的旋转算法
        function rotateSemicircleAsRigidBody(uLoop, targetPosition) {
            if (!uLoop || !uLoop.originalPoints) return;

            const startTop = points[uLoop.startTopIndex];
            const endTop = points[uLoop.endTopIndex];
            const center = startTop.clone().lerp(endTop, 0.5);

            // 获取原始中点位置
            const originalMid = uLoop.originalPoints[uLoop.midPointIndex];
            const originalMidVector = new THREE.Vector3().subVectors(originalMid, center);

            // 计算目标向量
            const targetVector = new THREE.Vector3().subVectors(targetPosition, center);

            // 计算旋转角度
            const angle = calculateSemicircleRotationAngle(originalMidVector, targetVector, uLoop.rotationAxis);

            // 使用四元数进行旋转
            const quaternion = new THREE.Quaternion().setFromAxisAngle(uLoop.rotationAxis, angle);

            // 旋转所有半圆点（保持刚性）
            uLoop.allSemicirclePointIndices.forEach(pointIndex => {
                if (pointIndex >= points.length) return;

                const originalPoint = uLoop.originalPoints[pointIndex];
                if (!originalPoint) return;

                // 计算点相对于中心的向量
                const vectorFromCenter = new THREE.Vector3().subVectors(originalPoint, center);

                // 应用旋转
                vectorFromCenter.applyQuaternion(quaternion);
                const newPosition = center.clone().add(vectorFromCenter);

                // 更新数据层
                points[pointIndex].copy(newPosition);

                // 更新界面层（所有可见点）
                const marker = draggableObjects.find(m => m.userData.index === pointIndex);
                if (marker && marker.visible) {
                    marker.position.copy(newPosition);
                }
            });
        }
                //计算半圆旋转角度
        function calculateSemicircleRotationAngle(originalVector, targetVector, axis) {
            // 将向量投影到旋转轴的垂直平面
            const originalProj = new THREE.Vector3().copy(originalVector);
            const targetProj = new THREE.Vector3().copy(targetVector);

            // 移除轴向分量
            const axisDotOriginal = originalProj.dot(axis);
            const axisDotTarget = targetProj.dot(axis);

            originalProj.sub(axis.clone().multiplyScalar(axisDotOriginal));
            targetProj.sub(axis.clone().multiplyScalar(axisDotTarget));

            // 归一化
            originalProj.normalize();
            targetProj.normalize();

            // 计算角度
            let angle = originalProj.angleTo(targetProj);

            // 确定旋转方向（使用叉积判断）
            const cross = new THREE.Vector3().crossVectors(originalProj, targetProj);
            if (cross.dot(axis) < 0) {
                angle = -angle;
            }

            return angle;
        }

        // --- Smart Design Functions ---
        function generateSmartDesign() {
            if (smartModePoints.length !== 7) {
                statusMessage.textContent = '错误：需要恰好7个点';
                return;
            }

            saveState();

            // 7个点的顺序：
            // 0: 左侧端点
            // 1: 左侧方向点（用于确定左侧U型曲方向）
            // 2: 左侧尖牙
            // 3: 中切牙
            // 4: 右侧尖牙
            // 5: 右侧方向点（用于确定右侧U型曲方向）
            // 6: 右侧端点

            // 清空当前点，只保留智能模式的7个点
            points = [...smartModePoints];

            // --- 新增：在第三点和第四点之间自动增加一个点 ---
            const pointBetween2and3 = findSurfacePointBetweenPoints(points[2], points[3]);
            if (pointBetween2and3) {
                points.splice(3, 0, pointBetween2and3); // 在索引3插入（原索引3变为4）
            }

            // --- 新增：在第四点和第五点之间自动增加一个点 ---
            const pointBetween4and5 = findSurfacePointBetweenPoints(points[4], points[5]);
            if (pointBetween4and5) {
                points.splice(5, 0, pointBetween4and5); // 在索引5插入（原索引5变为6）
            }

            // 重新索引后的点：
            // 0: 左侧端点
            // 1: 左侧方向点
            // 2: 左侧尖牙
            // 3: 新增点（左侧尖牙-中切牙之间）
            // 4: 中切牙
            // 5: 新增点（中切牙-右侧尖牙之间）
            // 6: 右侧尖牙
            // 7: 右侧方向点
            // 8: 右侧端点

            // 生成左侧U型曲（点0和点2之间）- 使用方向点1确定方向
            const leftYHat = calculateYHatFromDirectionPoint(
                points[0], // 左侧端点
                points[2], // 左侧尖牙
                points[1]  // 左侧方向点
            );

            const leftULoopGeometry = generateULoopGeometry(
                points[0], // 起点
                points[2], // 终点（左侧尖牙）
                leftYHat,
                uLoopHeight,
                0,  // index1
                2   // index2
            );

            // 生成右侧U型曲（点6和点8之间）- 使用方向点7确定方向
            const rightYHat = calculateYHatFromDirectionPoint(
                points[6], // 右侧尖牙
                points[8], // 右侧端点
                points[7]  // 右侧方向点
            );

            const rightULoopGeometry = generateULoopGeometry(
                points[6], // 起点（右侧尖牙）
                points[8], // 终点（右侧端点）
                rightYHat,
                uLoopHeight,
                6,  // index1
                8   // index2
            );

            // 生成左侧延伸弓丝（朝向牙弓内部）
            const leftExtension = generateExtensionWire(
                points[0], // 起点（左侧端点）
                leftYHat.clone().negate(), // 朝向牙弓内部（与U型曲方向相反）
                uLoopHeight * 0.8, // 延伸长度（U型曲高度的80%）
                true // 是左侧
            );

            // 生成右侧延伸弓丝（朝向牙弓内部）
            const rightExtension = generateExtensionWire(
                points[8], // 起点（右侧端点）
                rightYHat.clone().negate(), // 朝向牙弓内部（与U型曲方向相反）
                uLoopHeight * 0.8, // 延伸长度（U型曲高度的80%）
                false // 是右侧
            );

            // 构建最终的点序列
            const finalPoints = [
                // 左侧延伸弓丝（从内端点到左侧端点）
                ...leftExtension.reverse(),
                points[0], // 左侧端点
                ...leftULoopGeometry, // 左侧U型曲
                points[2], // 左侧尖牙
                points[3], // 新增点（左侧尖牙-中切牙之间）
                points[4], // 中切牙
                points[5], // 新增点（中切牙-右侧尖牙之间）
                points[6], // 右侧尖牙
                ...rightULoopGeometry, // 右侧U型曲
                points[8], // 右侧端点
                ...rightExtension // 右侧延伸弓丝
            ];

            points = finalPoints;

            // 计算索引偏移量（由于添加了延伸弓丝和新增点）
            const leftExtensionLength = leftExtension.length;
            const rightExtensionLength = rightExtension.length;

            // 计算左侧U型曲的索引
            const leftStartIndex = leftExtensionLength;
            const leftEndIndex = leftStartIndex + leftULoopGeometry.length;
            const leftStartTopIndex = leftStartIndex + 1;
            const leftEndTopIndex = leftEndIndex - 1;
            const leftMidPointIndex = leftStartIndex + Math.floor(leftULoopGeometry.length / 2);

            // 计算右侧U型曲的索引
            const rightStartIndex = leftEndIndex + 5 + rightExtensionLength; // +5 因为有5个中间点：左侧尖牙、新增点1、中切牙、新增点2、右侧尖牙
            const rightEndIndex = rightStartIndex + rightULoopGeometry.length;
            const rightStartTopIndex = rightStartIndex + 1;
            const rightEndTopIndex = rightEndIndex - 1;
            const rightMidPointIndex = rightStartIndex + Math.floor(rightULoopGeometry.length / 2);

            // 生成左侧U型曲的所有半圆点索引
            const leftAllSemicircleIndices = [];
            for (let i = leftStartTopIndex; i <= leftEndTopIndex; i++) {
                leftAllSemicircleIndices.push(i);
            }

            // 生成右侧U型曲的所有半圆点索引
            const rightAllSemicircleIndices = [];
            for (let i = rightStartTopIndex; i <= rightEndTopIndex; i++) {
                rightAllSemicircleIndices.push(i);
            }

            // 生成内部点索引（排除顶部点和中点）
            const leftInternalIndices = leftAllSemicircleIndices.filter(i =>
                i !== leftStartTopIndex && i !== leftEndTopIndex && i !== leftMidPointIndex
            );

            const rightInternalIndices = rightAllSemicircleIndices.filter(i =>
                i !== rightStartTopIndex && i !== rightEndTopIndex && i !== rightMidPointIndex
            );

            // 正确设置U型曲元数据
            uLoopSegments = [
                {
                    // 左侧U型曲
                    startIndex: leftStartIndex,
                    endIndex: leftEndIndex,
                    startTopIndex: leftStartTopIndex,
                    endTopIndex: leftEndTopIndex,
                    midPointIndex: leftMidPointIndex,
                    internalPointIndices: leftInternalIndices,
                    allSemicirclePointIndices: leftAllSemicircleIndices,
                    originalYHat: leftYHat.clone(),
                    originalHeight: uLoopHeight,
                    numSemicirclePoints: leftULoopGeometry.length - 1
                },
                {
                    // 右侧U型曲
                    startIndex: rightStartIndex,
                    endIndex: rightEndIndex,
                    startTopIndex: rightStartTopIndex,
                    endTopIndex: rightEndTopIndex,
                    midPointIndex: rightMidPointIndex,
                    internalPointIndices: rightInternalIndices,
                    allSemicirclePointIndices: rightAllSemicircleIndices,
                    originalYHat: rightYHat.clone(),
                    originalHeight: uLoopHeight,
                    numSemicirclePoints: rightULoopGeometry.length - 1
                }
            ];

            redrawScene();
            statusMessage.textContent = '智能设计生成完成（包含延伸弓丝和新增表面点）';
        }

        // --- 新的辅助函数：从方向点计算Y方向 ---
        function calculateYHatFromDirectionPoint(startPoint, endPoint, directionPoint) {
            const x_hat = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
            const toDirection = new THREE.Vector3().subVectors(directionPoint, startPoint);

            // 计算垂直于x_hat的分量
            const y_hat = toDirection.clone().sub(x_hat.clone().multiplyScalar(toDirection.dot(x_hat))).normalize();

            // 如果分量太小，使用默认的垂直方向
            if (y_hat.length() < 0.001) {
                y_hat.crossVectors(x_hat, planeNormal).normalize();
            }

            // 在原方向基础上旋转30度
            const rotationAngle = -Math.PI / 24; // 30度
            const rotationAxis = x_hat.clone(); // 绕X轴旋转

            // 创建四元数进行旋转
            const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, -rotationAngle);
            y_hat.applyQuaternion(quaternion);

            return y_hat.normalize();
        }

        // --- Helper Functions ---
        function findULoopByPointIndex(index) {
            if (index < 0 || index >= points.length) return null;

            const pointData = points[index].userData;

            // 首先尝试通过baseIndex查找
            if (pointData && pointData.type === 'uloop' && pointData.baseIndex !== undefined) {
                for (const uLoop of uLoopSegments) {
                    if (uLoop.startIndex === pointData.baseIndex) {
                        return uLoop;
                    }
                }
            }

            // 然后通过具体点索引精确查找
            for (const uLoop of uLoopSegments) {
                // 检查所有相关点
                if (uLoop.startIndex === index || uLoop.endIndex === index ||
                    uLoop.startTopIndex === index || uLoop.endTopIndex === index ||
                    uLoop.midPointIndex === index ||
                    (uLoop.internalPointIndices && uLoop.internalPointIndices.includes(index)) ||
                    (uLoop.allSemicirclePointIndices && uLoop.allSemicirclePointIndices.includes(index))) {
                    return uLoop;
                }
            }

            // 最后通过范围查找
            for (const uLoop of uLoopSegments) {
                if (index >= uLoop.startIndex && index <= uLoop.endIndex) {
                    return uLoop;
                }
            }

            return null;
        }

        function deselectAllPoints() {
            uLoopSelectionIndices.forEach(i => {
                const marker = draggableObjects.find(m => m.userData.index === i);
                if (marker) {
                    if (points[i].userData?.type === 'uloop') {
                        if (points[i].userData.role === 'mid') {
                            marker.material.color.set(0x00FF00); // 绿色
                        } else if (points[i].userData.role === 'start_top' || points[i].userData.role === 'end_top') {
                            marker.material.color.set(0xFFA500); // 橙色
                        } else {
                            marker.material.color.set(0x9932CC); // 紫色
                        }
                    } else {
                        marker.material.color.set(0xff0000); // 红色
                    }
                }
            });
            uLoopSelectionIndices = [];
            generateULoopBtn.disabled = true;
        }
        function handleULoopSelection(marker) {
            const index = marker.userData.index;
            const pointData = points[index].userData;

            // 如果是U型曲中点，准备整体旋转
            if (pointData && pointData.type === 'uloop' && pointData.role === 'mid') {
                prepareRigidRotation(index);
                return; // 不进行常规选择
            }

            // 如果是U型曲顶部点，直接选中
            if (pointData && pointData.type === 'uloop' &&
                (pointData.role === 'start_top' || pointData.role === 'end_top')) {
                const selectionIndex = uLoopSelectionIndices.indexOf(index);
                if (selectionIndex > -1) {
                    uLoopSelectionIndices.splice(selectionIndex, 1);
                    marker.material.color.set(0xFFA500); // 恢复橙色
                } else {
                    if (uLoopSelectionIndices.length >= 2) {
                        const oldIndex = uLoopSelectionIndices.shift();
                        const oldMarker = draggableObjects.find(m => m.userData.index === oldIndex);
                        if (oldMarker) oldMarker.material.color.set(0xFFA500); // 恢复橙色
                    }
                    uLoopSelectionIndices.push(index);
                    marker.material.color.set(SELECTION_COLOR_ULOOP); // 选中颜色
                }
                generateULoopBtn.disabled = uLoopSelectionIndices.length !== 2;
                return;
            }

            function prepareRigidRotation(midIndex) {
                // 找到包含这个中点的U型曲
                const uLoop = uLoopSegments.find(seg => seg.midPointIndex === midIndex);
                if (!uLoop) {
                    console.warn('未找到包含中点的U型曲:', midIndex);
                    return;
                }

                // 保存所有半圆点的原始位置
                uLoop.originalPoints = {};
                uLoop.allSemicirclePointIndices.forEach(pointIndex => {
                    if (pointIndex < points.length) {
                        uLoop.originalPoints[pointIndex] = points[pointIndex].clone();
                    }
                });

                uLoop.isRotating = true;

                // 计算旋转轴（连接两个顶部点的向量）
                if (uLoop.startTopIndex < points.length && uLoop.endTopIndex < points.length) {
                    const startTop = points[uLoop.startTopIndex];
                    const endTop = points[uLoop.endTopIndex];
                    uLoop.rotationAxis = new THREE.Vector3()
                        .subVectors(endTop, startTop)
                        .normalize();
                } else {
                    console.warn('顶部点索引超出范围');
                    uLoop.rotationAxis = new THREE.Vector3(0, 1, 0); // 默认Y轴
                }

                // 保存中心点位置
                const startTop = points[uLoop.startTopIndex];
                const endTop = points[uLoop.endTopIndex];
                uLoop.center = startTop.clone().lerp(endTop, 0.5);
            }
            // 普通点选择逻辑
            const selectionIndex = uLoopSelectionIndices.indexOf(index);
            if (selectionIndex > -1) {
                uLoopSelectionIndices.splice(selectionIndex, 1);
                marker.material.color.set(0xff0000);
            } else {
                if (uLoopSelectionIndices.length >= 2) {
                    const oldIndex = uLoopSelectionIndices.shift();
                    const oldMarker = draggableObjects.find(m => m.userData.index === oldIndex);
                    if (oldMarker) oldMarker.material.color.set(0xff0000);
                }
                uLoopSelectionIndices.push(index);
                marker.material.color.set(SELECTION_COLOR_ULOOP);
            }
            generateULoopBtn.disabled = uLoopSelectionIndices.length !== 2;
        }
        // --- 新的辅助函数：生成延伸弓丝 ---
        function generateExtensionWire(startPoint, direction, length, isLeft) {
            const extensionPoints = [];
            const numSegments = 5; // 延伸弓丝的段数

            // 计算延伸方向（稍微向牙弓中心偏转）
            const centerDirection = new THREE.Vector3(0, 0, isLeft ? 0.2 : -0.2); // 左侧向右偏，右侧向左偏
            const finalDirection = direction.clone().add(centerDirection).normalize();

            // 生成延伸弓丝的点
            for (let i = 0; i <= numSegments; i++) {
                const t = i / numSegments;
                // 使用缓动函数使弓丝更平滑
                const easedT = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                const point = startPoint.clone().add(finalDirection.clone().multiplyScalar(length * easedT));

                // 为延伸弓丝的端点添加特殊标记
                if (i === numSegments) {
                    point.userData = {
                        type: 'extension_end',
                        side: isLeft ? 'left' : 'right'
                    };
                } else if (i === 0) {
                    point.userData = {
                        type: 'extension_start',
                        side: isLeft ? 'left' : 'right'
                    };
                } else {
                    point.userData = {
                        type: 'extension',
                        side: isLeft ? 'left' : 'right'
                    };
                }

                extensionPoints.push(point);
            }

            return extensionPoints;
        }
        function findSurfacePointBetweenPoints(pointA, pointB) {
            if (!dentalModel) {
                console.warn('无法找到表面点：牙模未加载');
                return null;
            }

            // 计算两点之间的中点
            const midpoint = new THREE.Vector3().lerpVectors(pointA, pointB, 0.5);

            // 创建从相机指向中点的射线
            const direction = new THREE.Vector3().subVectors(midpoint, camera.position).normalize();
            const rayOrigin = camera.position.clone();

            // 创建射线并检测与牙模的交点
            const ray = new THREE.Raycaster(rayOrigin, direction);
            const intersects = ray.intersectObject(dentalModel);

            if (intersects.length > 0) {
                // 找到最近的交点
                const closestIntersect = intersects[0];

                // 使用getOffsetPoint获取牙齿表面的点（带偏移）
                const surfacePoint = getOffsetPoint(closestIntersect);

                // 设置点的用户数据
                surfacePoint.userData = {
                    type: 'auto_surface',
                    generated: true,
                    betweenPoints: [pointA, pointB]
                };

                return surfacePoint;
            }

            // 如果射线检测失败，使用简单的中点偏移
            const fallbackPoint = midpoint.clone();
            const normal = new THREE.Vector3(0, 1, 0); // 默认使用Y轴法线
            fallbackPoint.add(normal.multiplyScalar(wireRadius));

            fallbackPoint.userData = {
                type: 'auto_surface_fallback',
                generated: true,
                betweenPoints: [pointA, pointB]
            };

            return fallbackPoint;
        }

        function correctULoopAfterDrag(uLoop) {
            if (!uLoop) {
                console.error('U型曲数据不存在');
                return;
            }

            saveState();

            const baseStart = points[uLoop.startIndex];
            const baseEnd = points[uLoop.endIndex];
            const startTop = points[uLoop.startTopIndex];
            const endTop = points[uLoop.endTopIndex];

            if (!baseStart || !baseEnd || !startTop || !endTop) {
                console.error('U型曲点数据不完整');
                return;
            }

            // 1. 校正顶部点位置，确保与基础点保持垂直关系
            const startTopDir = new THREE.Vector3().subVectors(startTop, baseStart).normalize();
            const startTopCorrected = baseStart.clone().add(startTopDir.multiplyScalar(uLoop.originalHeight));
            points[uLoop.startTopIndex].copy(startTopCorrected);

            const endTopDir = new THREE.Vector3().subVectors(endTop, baseEnd).normalize();
            const endTopCorrected = baseEnd.clone().add(endTopDir.multiplyScalar(uLoop.originalHeight));
            points[uLoop.endTopIndex].copy(endTopCorrected);

            // 2. 更新界面标记点
            const startTopMarker = draggableObjects.find(m => m.userData.index === uLoop.startTopIndex);
            const endTopMarker = draggableObjects.find(m => m.userData.index === uLoop.endTopIndex);
            if (startTopMarker) startTopMarker.position.copy(startTopCorrected);
            if (endTopMarker) endTopMarker.position.copy(endTopCorrected);

            // 3. 重新生成整个半圆
            const x_hat = new THREE.Vector3().subVectors(endTopCorrected, startTopCorrected).normalize();
            const y_hat = planeNormal.clone();

            // 确保y_hat与x_hat垂直
            const dot = x_hat.dot(y_hat);
            if (Math.abs(dot) > 0.1) {
                y_hat.sub(x_hat.clone().multiplyScalar(dot)).normalize();
            }

            const z_hat = new THREE.Vector3().crossVectors(x_hat, y_hat).normalize();
            const semicircleCenter = startTopCorrected.clone().lerp(endTopCorrected, 0.5);
            const radius = startTopCorrected.distanceTo(semicircleCenter);

            // 4. 重新计算所有半圆点
            const startVec = new THREE.Vector3().subVectors(startTopCorrected, semicircleCenter);

            for (let i = 1; i < uLoop.numSemicirclePoints; i++) {
                const angle = -Math.PI * (i / uLoop.numSemicirclePoints);
                const semicirclePoint = startVec.clone().applyAxisAngle(z_hat, angle).add(semicircleCenter);

                const pointIndex = uLoop.startTopIndex + i;
                if (pointIndex < points.length) {
                    points[pointIndex].copy(semicirclePoint);

                    // 更新界面标记点（仅中点可见）
                    if (pointIndex === uLoop.midPointIndex) {
                        const midMarker = draggableObjects.find(m => m.userData.index === pointIndex);
                        if (midMarker) midMarker.position.copy(semicirclePoint);
                    }
                }
            }

            // 5. 更新U型曲的旋转轴
            uLoop.rotationAxis = new THREE.Vector3()
                .subVectors(points[uLoop.endTopIndex], points[uLoop.startTopIndex])
                .normalize();

            // 6. 刷新显示
            updateArchCurve();
            setupDragControls();
        }

        function exportJSON() {
            if (points.length === 0) {
                alert('没有点可以导出！');
                return;
            }


            const pointsCount = parseInt(document.getElementById('points-count').value);
            if (isNaN(pointsCount) || pointsCount <= 1) {
                alert('请输入一个有效的离散点数！');
                return;
            }


            const finalPoints = [];
            let currentPoints = [];
            let currentIsULoop = false;

            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const isULoopPoint = point.userData && point.userData.type === 'uloop';

                if (isULoopPoint !== currentIsULoop || i === 0) {
                    if (currentPoints.length > 1) {
                        const curvePoints = currentIsULoop
                            ? currentPoints
                            : createSmoothCurvePoints(currentPoints, Math.floor(pointsCount / points.length));
                        finalPoints.push(...curvePoints);
                    }
                    currentPoints = [point];
                    currentIsULoop = isULoopPoint;
                } else {
                    currentPoints.push(point);
                }
            }
            if (currentPoints.length > 1) {
                const curvePoints = currentIsULoop
                    ? currentPoints
                    : createSmoothCurvePoints(currentPoints, Math.floor(pointsCount / points.length));
                finalPoints.push(...curvePoints);
            } else if (currentPoints.length === 1) {
                finalPoints.push(currentPoints[0]);
            }


            const data = {
                points: finalPoints.map(p => ({ x: p.x, y: p.y, z: p.z })),
                uLoopSegments: uLoopSegments.map(s => ({
                    startIndex: s.startIndex,
                    endIndex: s.endIndex,
                    startTopIndex: s.startTopIndex,
                    endTopIndex: s.endTopIndex,
                    midPointIndex: s.midPointIndex
                }))
            };


            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dental_arch_design.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importJSON(event) {//监听导入json按钮点击事件
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.points && Array.isArray(data.points)) {
                        // 更新状态，不显示导入面板
                        document.getElementById('initial-modal').style.display = 'none';

                        points = data.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
                        redrawScene();
                        statusMessage.textContent = "设计导入成功。";
                    } else {
                        statusMessage.textContent = "导入失败：JSON格式不正确。";
                    }
                } catch (error) {
                    console.error("Error parsing JSON file:", error);
                    statusMessage.textContent =  "导入失败：无效的JSON文件。" ;
                }
            };
            reader.readAsText(file);
        }

        function animate() {
            requestAnimationFrame(animate);//请求浏览器在下一次重绘之前调用animate函数，每次绘制都会调用，循环
            renderer.render(scene, camera);//命令Three.js渲染器将3D场景绘制到Canvas元素上
        }

        //关闭导入界面按钮禁用
        function disablePageInteraction() {
            document.getElementById('export-btn').disabled = true;
            document.getElementById('save-btn').disabled = true;
            document.getElementById('undo-btn').disabled = true;
            document.getElementById('redo-btn').disabled = true;
            document.getElementById('clear-design').disabled = true;
            document.getElementById('reset-all').disabled = true;
            document.getElementById('plane-adjust').disabled = true;
            document.getElementById('plane-confirm').disabled = true;
            document.getElementById('plane-reset').disabled = true;
            document.getElementById('mode-manual').disabled = true;
            document.getElementById('mode-auto').disabled = true;
            if (dragControls) dragControls.enabled = false;
        }
        //各种弹窗
        function initStyleAdjust() {
            // 帮助弹窗事件
            document.getElementById('help-btn').addEventListener('click', () => {
                document.getElementById('help-modal').style.display = 'flex';
            });
            document.getElementById('close-help').addEventListener('click', () => {
                document.getElementById('help-modal').style.display = 'none';
            });
            document.getElementById('help-modal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('help-modal')) {
                    document.getElementById('help-modal').style.display = 'none';
                }
            });

            // 样式调整弹窗事件
            const styleModal = document.getElementById('style-modal');
            document.getElementById('style-adjust').addEventListener('click', () => {
                updateStyleSliders(); // 更新滑块状态
                styleModal.style.display = 'flex';
            });
            document.getElementById('close-style').addEventListener('click', () => {
                styleModal.style.display = 'none';
            });
            styleModal.addEventListener('click', (e) => {
                if (e.target === styleModal) styleModal.style.display = 'none';
            });

            // 模型透明度调整
            const modelOpacitySlider = document.getElementById('model-opacity');
            const modelOpacityValue = document.getElementById('model-opacity-value');
            modelOpacitySlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value) / 100;
                modelOpacityValue.textContent = value.toFixed(1);
                if (dentalModel) {
                    dentalModel.material.opacity = value;
                    currentModelOpacity = value;
                }
            });

            // 平面透明度调整
            const planeOpacitySlider = document.getElementById('plane-opacity-adjust');
            const planeOpacityValue = document.getElementById('plane-opacity-value');
            planeOpacitySlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value) / 100;
                planeOpacityValue.textContent = value.toFixed(1);
                if (referencePlaneMesh) {
                    referencePlaneMesh.material.opacity = value;
                    currentPlaneOpacity = value;
                }
            });
        }
        //样式调整滑条
        function updateStyleSliders() {
            const modelOpacitySlider = document.getElementById('model-opacity');
            const modelOpacityValue = document.getElementById('model-opacity-value');
            const planeOpacitySlider = document.getElementById('plane-opacity-adjust');
            const planeOpacityValue = document.getElementById('plane-opacity-value');

            // 模型透明度
            if (dentalModel) {
                modelOpacitySlider.disabled = false;
                modelOpacitySlider.value = Math.round(currentModelOpacity * 100);
                modelOpacityValue.textContent = currentModelOpacity.toFixed(1);
            } else {
                modelOpacitySlider.disabled = true;
                modelOpacitySlider.value = 100;
                modelOpacityValue.textContent = '1.0';
            }

            // 平面透明度
            if (referencePlaneMesh) {
                planeOpacitySlider.disabled = false;
                planeOpacitySlider.value = Math.round(currentPlaneOpacity * 100);
                planeOpacityValue.textContent = currentPlaneOpacity.toFixed(1);
            } else {
                planeOpacitySlider.disabled = true;
                planeOpacitySlider.value = 50;
                planeOpacityValue.textContent = '0.5';
            }
        }
        // 控制面板折叠/展开
        function togglePanel() {
            isPanelExpanded = !isPanelExpanded;
            const content = document.getElementById('panel-content');
            const toggle = document.getElementById('panel-toggle').querySelector('.panel-toggle');

            if (isPanelExpanded) {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▲';
            }
        }
        //选择设计模式
        function setDesignMode(mode) {
    // 隐藏步骤1和步骤2的内容，但保留标题
    document.getElementById('step-1-content').style.display = 'none';
    document.getElementById('step-1').querySelector('.step-title').innerHTML = 'Step 1: 建立参考平面 ▲';

    document.getElementById('step-2-content').style.display = 'none';
    document.getElementById('step-2').querySelector('.step-title').innerHTML = 'Step 2: 选择绘制模式 ▲';

    // 隐藏所有模式面板
    document.getElementById('step-2.1').style.display = 'none';
    document.getElementById('step-2.2').style.display = 'none';

    // 根据选择的模式显示对应的面板
    if (mode === 'manual') {
        document.getElementById('step-2.1').style.display = 'block';
        document.getElementById('step-2.2').style.display = 'none';
        // 默认收起内容
        document.getElementById('step-2.1-content').style.display = 'block';
        document.getElementById('step-2.1').querySelector('.step-title').innerHTML = '当前模式: 自由绘制 ▼';
    } else if (mode === 'auto') {
        document.getElementById('step-2.1').style.display = 'none';
        document.getElementById('step-2.2').style.display = 'block';
        // 默认收起内容
        document.getElementById('step-2.2-content').style.display = 'block';
        document.getElementById('step-2.2').querySelector('.step-title').innerHTML = '当前模式: 智能生成 ▼';
    }

    // 更新设计部分显示状态
    document.getElementById('design-section').classList.remove('hidden');
    document.getElementById('export-section').classList.remove('hidden');
}
        // 重置所有
        function resetAll() {
            // 清除模型
            if (dentalModel) {
                scene.remove(dentalModel);
                dentalModel = null;
            }

            // 清除平面和设计
            resetPlane();
            clearCurrentDesign(false);

            // 重置历史
            historyStack = [];
            redoStack = [];
            updateHistoryButtons();

            // 重置UI状态
            document.getElementById('export-btn').disabled = true;
            document.getElementById('save-btn').disabled = true;
            document.getElementById('step-2').style.display = 'none';
            disablePageInteraction();
            document.getElementById('initial-modal').style.display = 'flex';
        }
        // 添加步骤折叠/展开功能
        // 在 <script type="module"> 内部修改函数定义
        window.toggleStep = function(contentId) {
            const content = document.getElementById(contentId);
            if (!content) return; // 防止找不到元素报错

            // 切换内容显示状态
            const isHidden = content.style.display === 'none' || content.style.display === '';
            content.style.display = isHidden ? 'block' : 'none';

            // 找到对应的标题元素（包含箭头的元素）
            const titleElement = content.previousElementSibling;
            if (titleElement && titleElement.classList.contains('step-title')) {
                // 切换箭头符号（▲和▼互换）
                if (titleElement.textContent.includes('▼')) {
                    titleElement.textContent = titleElement.textContent.replace('▼', '▲');
                } else if (titleElement.textContent.includes('▲')) {
                    titleElement.textContent = titleElement.textContent.replace('▲', '▼');
                }
            }
        };

    // 替换原有的视角切换初始化函数
function initViewSwitcher() {
    // 创建视角切换弹窗
    const viewSwitcher = document.createElement('div');
    viewSwitcher.id = 'view-switcher';
    viewSwitcher.className = 'view-switcher hidden';
    viewSwitcher.innerHTML = `
        <div class="view-grid">
            <!-- 第一列：定义视角按钮 -->
            <div class="view-column">
                <button class="view-btn define-view" data-action="define-front">定义前视角</button>
            </div>

            <!-- 第二列：上下前后按钮 -->
            <div class="view-column">
                <button class="view-btn" data-view="front">前视图</button>
                <button class="view-btn" data-view="back">后视图</button>
                <button class="view-btn" data-view="top">顶视图</button>
                <button class="view-btn" data-view="bottom">底视图</button>
            </div>

            <!-- 第三列：左右按钮 -->
            <div class="view-column">
                <button class="view-btn" data-view="left">左视图</button>
                <button class="view-btn" data-view="right">右视图</button>
            </div>
        </div>
    `;
    document.body.appendChild(viewSwitcher);

    // 存储用户定义的前视角
    let userDefinedFrontView = {
        position: new THREE.Vector3(0, 0, 100),
        target: new THREE.Vector3(0, 0, 0)
    };

    // 获取相关元素
    const viewSwitchBtn = document.getElementById('view-switch');
    const switcher = document.getElementById('view-switcher');

    // 显示弹窗（向上弹出）
    viewSwitchBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const rect = viewSwitchBtn.getBoundingClientRect();
        switcher.style.left = `${rect.left}px`;
        switcher.style.bottom = `${window.innerHeight - rect.top + 5}px`;
        switcher.style.top = 'auto';
        switcher.classList.remove('hidden');
    });

    // 点击外部关闭弹窗
    document.addEventListener('click', (e) => {
        if (!switcher.contains(e.target) && e.target !== viewSwitchBtn) {
            switcher.classList.add('hidden');
        }
    });

    // 定义前视角功能
    document.querySelector('.define-view').addEventListener('click', () => {
        // 保存当前相机位置和目标点作为前视角
        userDefinedFrontView.position.copy(camera.position);
        userDefinedFrontView.target.copy(orbitControls.target);
        statusMessage.textContent = '已定义当前视角为前视图';
        switcher.classList.add('hidden');
    });

    // 视角切换逻辑
    document.querySelectorAll('.view-btn[data-view]').forEach(btn => {
        btn.addEventListener('click', () => {
            const view = btn.dataset.view;
            const target = new THREE.Vector3().copy(userDefinedFrontView.target);

            switch(view) {
                case 'front':
                    // 使用用户定义的前视角
                    camera.position.copy(userDefinedFrontView.position);
                    break;
                case 'back':
                    // 后视图：与前视图相对
                    camera.position.copy(userDefinedFrontView.position).multiplyScalar(-1);
                    break;
                case 'left': {
                    // 左视图：基于前视角计算
                    const frontDir = new THREE.Vector3()
                        .subVectors(userDefinedFrontView.target, userDefinedFrontView.position)
                        .normalize();
                    const leftDir = new THREE.Vector3().crossVectors(orbitControls.object.up, frontDir).normalize()
                        .multiplyScalar(userDefinedFrontView.position.distanceTo(target));
                    camera.position.copy(target).add(leftDir);
                    break;
                }
                case 'right': {
                    // 右视图：与左视图相对
                    const frontDir = new THREE.Vector3()
                        .subVectors(userDefinedFrontView.target, userDefinedFrontView.position)
                        .normalize();
                    const rightDir = new THREE.Vector3().crossVectors(frontDir, orbitControls.object.up).normalize()
                        .multiplyScalar(userDefinedFrontView.position.distanceTo(target));
                    camera.position.copy(target).add(rightDir);
                    break;
                }
                case 'top': {
                    // 顶视图：基于前视角上方向
                    const frontDir = new THREE.Vector3()
                        .subVectors(userDefinedFrontView.target, userDefinedFrontView.position)
                        .normalize();
                    const topDir = new THREE.Vector3().crossVectors(frontDir, new THREE.Vector3(1, 0, 0)).normalize()
                        .multiplyScalar(userDefinedFrontView.position.distanceTo(target));
                    camera.position.copy(target).add(topDir);
                    break;
                }
                case 'bottom': {
                    // 底视图：与顶视图相对
                    const frontDir = new THREE.Vector3()
                        .subVectors(userDefinedFrontView.target, userDefinedFrontView.position)
                        .normalize();
                    const bottomDir = new THREE.Vector3().crossVectors(new THREE.Vector3(1, 0, 0), frontDir).normalize()
                        .multiplyScalar(userDefinedFrontView.position.distanceTo(target));
                    camera.position.copy(target).add(bottomDir);
                    break;
                }
            }

            camera.lookAt(target);
            orbitControls.target.copy(target);
            orbitControls.update();
            switcher.classList.add('hidden');
        });
    });
}

// 更新弹窗样式
const style = document.createElement('style');
style.textContent = `
    .view-switcher {
        position: absolute;
        background: #333;
        border-radius: 6px;
        padding: 8px;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
        z-index: 1000;
    }
    .view-grid {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 8px;
    }
    .view-column {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    .view-btn {
        padding: 6px 8px;
        background: #555;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        text-align: center;
        white-space: nowrap;
    }
    .view-btn.define-view {
        background: #4a6fa5;
    }
    .view-btn:hover {
        background: #666;
    }
    .view-btn.define-view:hover {
        background: #5a8ac5;
    }
    .hidden {
        display: none;
    }
`;
document.head.appendChild(style);
        init();
    </script>
</body>
</html>